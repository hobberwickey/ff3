<div>
  
  <canvas id='screen' width='512' height='512' style='transform: translate3d(0,0,0);'></canvas>
  <div id='drawTime'></div>
  <div id='stop'><a href='javascript:void(0)'>Stop</a></div>
  
  <script>
    var palette = JSON.parse('<%= @map.palette.to_json %>'),
        tiles = JSON.parse('<%= @map.tiles.to_json %>'),
        map_data = JSON.parse('<%= @map.layer_data.to_json %>'),
        dimensions = JSON.parse('<%= @map.info.dimensions.to_json %>'),
        sprites = JSON.parse('<%= @map.sprite_info.sprites.to_json %>'),
        paused = false,

        SPRITE_POSITIONS = JSON.parse('<%= @map.sprite_info.sprite_positions.to_json %>')
        MAP_SIZE = [<%= @map.map_info.map_viewable_size[:x] %>, <%= @map.map_info.map_viewable_size[:y] %>]

    var ctx, dataObj, data, layers, scrollPos, scrollSpeed, animated_frame;
    var scrollL = scrollR = scrollU = scrollD = false;

    // document.addEventListener("polymer-ready", function(){
    var ctx = document.querySelector("#screen").getContext("2d"),
        dataObj = ctx.getImageData(0,0,512,512),
        data = dataObj.data;

    var layers = [
        { data: tiles[0].p, index: 0, x: 0, x_offset: 0, y: 0, y_offset: 0 },
        { data: tiles[1].p, index: 1, x: 0, x_offset: 0, y: 0, y_offset: 0 },
        { data: tiles[0].r, index: 0, x: 0, x_offset: 0, y: 0, y_offset: 0 },
        { data: tiles[1].r, index: 1, x: 0, x_offset: 0, y: 0, y_offset: 0 }
      ]

    var scrollPos = {
        x: 0,
        y: 0,
        x_offset: 0,
        y_offset: 0
      }

    var pixelMap = []
    for (var i=0; i<256; i++){
      pixelMap[i] = [];
      for (var j=0; j<256; j++){
        pixelMap[i][j] = 0;
      }
    }

    var animated_frame = 0;

    setInterval(function(){
      animated_frame++;
      if (animated_frame >= 4) animated_frame = 0;
    }, 10)

    var test = document.querySelector("#drawTime");
  
    //var start = Date.now();
    var timing = [ 
      window.performance.now(), // start time
      0, // frames
      0, // last draw
      0  // advanced
    ]

    function loop(timestamp) {
      //if (Date.now() - start > fps){ //24 FPS
        var t = timing;

        ctx.putImageData(dataObj, 0, 0)

        checkActions();
        drawMap();
        drawSprites();
        
        t[1] = (timestamp - t[0]) >> 4;
        t[3] = t[1] - t[2];
        t[2] = t[1];

        test.innerHTML = ((window.performance.now() - timestamp) | 0) + " milliseconds to draw frame " + t[3];
        
      //}
      if (!paused) window.requestAnimationFrame(loop);
    }
    setupSpriteMovement();
    loop();
    
    function drawMap(){
      //var start = Date.now();

      var layers_len = layers.length;

      for (var i=0; i<256; i++){
        var x_offset = (i & 15) << 4,
            y_offset = (i >> 4) << 4
        
        for (var j=0; j<256; j++){
          var x = (j & 15) + x_offset,
              y = (j >> 4) + y_offset;

          var pixel, index = (x << 3) + ((y << 1) << 11);
          
          for (var z=0; z<layers_len;z++){
            var layer = layers[z];

            var map_x = (x_offset >> 4) + layer.x + scrollPos.x,
                map_y = (y_offset >> 4) + layer.y + scrollPos.y;

            //TODO: Get ride of the greater than checks
            var overflow_x = ((j & 15) + layer.x_offset + scrollPos.x_offset > 15) | 0,
                overflow_y = (j + ((layer.y_offset + scrollPos.y_offset) << 4) > 255) | 0,
                pixel_offset = j + layer.x_offset + scrollPos.x_offset + ((layer.y_offset + scrollPos.y_offset) << 4);

              
            map_x += overflow_x;
            map_y += overflow_y;

            pixel_offset -= overflow_x << 4;
            pixel_offset -= overflow_y << 8;

            var map_size = dimensions,
                map_index = (map_x & (map_size[layer.index].x - 1)) + ((map_y & (map_size[layer.index].y - 1)) * map_size[layer.index].x),
                m_data = map_data,
                tile_index = m_data[layer.index][map_index],
                tile_data = layer.data[tile_index];

            var animated_offset = pixel_offset + (256 * animated_frame);
            
            var color_index = tile_data[animated_offset] === void(0) ? tile_data[pixel_offset] : tile_data[animated_offset];

            pixel = palette[color_index];
            if( pixel[3] === 255 ){ 
              pixelMap[x][y] = layers_len - z
              break;
            }
          }
        
          drawPixel(data, pixel, index)
        }
      }
    }

    function drawSprites(){
      var _sprites = sprites,
          _scrollPos = scrollPos,
          _spritePositions = SPRITE_POSITIONS;

      var mapBounds = {
        x1: (_scrollPos.x << 4) + _scrollPos.x_offset,
        x2: (_scrollPos.x << 4) + _scrollPos.x_offset + 256,
        y1: (_scrollPos.y << 4) + _scrollPos.y_offset,
        y2: (_scrollPos.y << 4) + _scrollPos.y_offset + 256,

      }

      for (var i=0; i<_sprites.length; i++){
        var sprite = _sprites[i],
          back_edge = (sprite.coords.x << 4) + sprite.coords.x_offset,
          top_edge = ((sprite.coords.y - 1) << 4) + sprite.coords.y_offset,
          spritePos = _spritePositions[sprite.position];

        if (back_edge + 16 > mapBounds.x1 && back_edge < mapBounds.x2 && top_edge + 24 > mapBounds.y1 && top_edge < mapBounds.y2){
          for (var b=0; b<6; b++){
            var x_offset = (b & 1) << 3,
                y_offset = (b >> 1) << 3;

            for (var y=0; y<8; y++){
              for (var x=0; x<8; x++){
                var color = sprite.tiles[spritePos[b]][x + (y << 3)],
                    x_pixel = sprite.mirror === 0 ? x + x_offset : 15 - (x + x_offset),
                    data_x = (back_edge - mapBounds.x1) + x_pixel,
                    data_y = (y + (top_edge - mapBounds.y1)) + y_offset;

                if (data_x < 0 || data_x > 255 || data_y < 0 || data_y > 255 || color[3] === 0) continue

                var data_offset = ((data_x * 2) + ((data_y * 2) * 512)) * 4
                if (pixelMap[data_x][data_y] <= sprite.priority) drawPixel(data, color, data_offset)
              }
            }
          }
        }
      }
    }

    //TODO: be able to set width. Needed for mode7
    function drawPixel(data, pal, index){
      data[index] = pal[0]
      data[index + 1] = pal[1]
      data[index + 2] = pal[2]
      data[index + 3] = pal[3]

      data[index + 4] = pal[0]
      data[index + 5] = pal[1]
      data[index + 6] = pal[2]
      data[index + 7] = pal[3]

      data[index + 2048] = pal[0]
      data[index + 2049] = pal[1]
      data[index + 2050] = pal[2]
      data[index + 2051] = pal[3]

      data[index + 2052] = pal[0]
      data[index + 2053] = pal[1]
      data[index + 2054] = pal[2]
      data[index + 2055] = pal[3]
    }

    window.addEventListener("keydown", function(e){
      if (e.keyCode === 37){
        scrollLeft(); scrollL = true;
      } else if (e.keyCode === 38) {
        scrollUp(); scrollU = true;
      } else if (e.keyCode === 39) {
        scrollRight(); scrollR = true;
      } else if (e.keyCode === 40) {
        scrollDown(); scrollD = true;
      }
    }, false)

    window.addEventListener("keyup", function(e){
      if (e.keyCode === 37){
        scrollL = false;
      } else if (e.keyCode === 38) {
        scrollU = false;
      } else if (e.keyCode === 39) {
        scrollR = false;
      } else if (e.keyCode === 40) {
        scrollD = false;
      }
    }, false)
    // })
  
    document.getElementById('stop').addEventListener("click", function(){
      if (paused === true){
        paused = false;
        loop();
      } else {
        paused = true;
      }
    }, false)

    function scrollLeft(){
      if (scrollL || scrollR || scrollPos.x === 0) return

      scrollPos.x_offset = 14;
      scrollPos.x -= 1;

      var t = setInterval(function(){
        scrollPos.x_offset -= 2;

        if (scrollPos.x_offset <= 0){
          if (scrollL === false || scrollPos.x === 0){ 
            scrollPos.x_offset = 0
            clearInterval(t);
          } else {
            scrollPos.x_offset = 14;
            scrollPos.x -= 1;
          }
        }
      }, 10);
    }

    function scrollRight(){
      if (scrollL || scrollR || scrollPos.x + 16 > dimensions[0].x) return

      scrollPos.x_offset += 2
      var t = setInterval(function(){
        scrollPos.x_offset += 2;

        if (scrollPos.x_offset >= 16){
          scrollPos.x_offset = 0;
          scrollPos.x += 1;
          if (scrollR === false || scrollPos.x + 16 > dimensions[0].x) clearInterval(t);
        }
      }, 10);
    }

    function scrollUp(){
      if (scrollU || scrollD || scrollPos.y === 0) return

      scrollPos.y_offset = 14;
      scrollPos.y -= 1;

      var t = setInterval(function(){
        scrollPos.y_offset -= 2;

        if (scrollPos.y_offset <= 0){
          if (scrollU === false || scrollPos.y === 0){ 
            scrollPos.y_offset = 0
            clearInterval(t);
          } else {
            scrollPos.y_offset = 14;
            scrollPos.y -= 1;
          }
        }
      }, 10);
    }

    function scrollDown(){
      if (scrollU || scrollD || scrollPos.y + 16 > dimensions[0].y) return

      scrollPos.y_offset += 2
      var t = setInterval(function(){
        scrollPos.y_offset += 2;

        if (scrollPos.y_offset >= 16){
          scrollPos.y_offset = 0;
          scrollPos.y += 1;
          if (scrollD === false || scrollPos.y + 16 > dimensions[0].y) clearInterval(t);
        }
      }, 10);
    }
  </script>
</div>