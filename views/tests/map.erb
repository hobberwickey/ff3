<div>
  <div id='drawTime'></div>
  <div id='stop'><a href='javascript:void(0)'>Stop</a></div>
  
  <div id='screen_wrapper' style='position: relative; width: 512px; height: 512px; margin: 0px auto; zoom: 2; overflow: hidden;'>
    <div id='props' style='position: absolute; width: 512px;'></div>
    <canvas id='screen' width='256' height='256' style='background-color: #00f; transform: scale(2); transform-origin: 0 0;'></canvas>
  </div>
  
  <script>
    var PALETTE = JSON.parse('<%= @map.palette.to_json %>'),
        TILES = JSON.parse('<%= @map.tiles.to_json %>'),
        MAP_DATA = JSON.parse('<%= @map.layer_data.to_json %>'),
        DIMENSIONS = JSON.parse('<%= @map.info.dimensions.to_json %>'),
        SPRITES = JSON.parse('<%= @map.sprite_info.sprites.to_json %>'),
        CHARACTER = JSON.parse('<%= @map.sprite_info.character.to_json %>'),
        TILE_PROPERTIES = JSON.parse('<%= @map.tile_properties.to_json %>'),
        PAUSED = false,

        SPRITE_POSITIONS = JSON.parse('<%= @map.sprite_info.sprite_positions.to_json %>'),
        MAP_SIZE = [<%= @map.map_info.map_viewable_size[:x] %>, <%= @map.map_info.map_viewable_size[:y] %>];
        PHYSICAL_MAP = {};

    var tile_props = document.getElementById("props");

    var ctx, dataObj, data, layers, scrollPos, scrollSpeed, animated_frame;
    var scrollL = scrollR = scrollU = scrollD = false;

    // document.addEventListener("polymer-ready", function(){
    var ctx = document.querySelector("#screen").getContext("2d"),
        dataObj = ctx.getImageData(0,0,256,256),
        data = dataObj.data;

    var layers = [
        { data: TILES[0].p, index: 0, x: 0, x_offset: 0, y: 0, y_offset: 0 },
        { data: TILES[1].p, index: 1, x: 0, x_offset: 0, y: 0, y_offset: 0 },
        { data: TILES[0].r, index: 0, x: 0, x_offset: 0, y: 0, y_offset: 0 },
        { data: TILES[1].r, index: 1, x: 0, x_offset: 0, y: 0, y_offset: 0 }
      ]

    var scrollPos = {
        x: 0,
        y: 0,
        x_offset: 0,
        y_offset: 0
      }

    var pixelMap = []
    for (var i=0; i<256; i++){
      pixelMap[i] = [];
      for (var j=0; j<256; j++){
        pixelMap[i][j] = 0;
      }
    }

    var animated_frame = 0;

    every(8, function(){
      animated_frame++;
      if (animated_frame >= 4) animated_frame = 0;
    }, false)
    

    var test = document.querySelector("#drawTime");
  
    //var start = Date.now();
    var timing = [ 
      window.performance.now(), // start time
      0, // frames
      0, // last draw
      0  // advanced
    ]

    function loop(timestamp) {
      //if (Date.now() - start > fps){ //24 FPS
        var t = timing;

        ctx.putImageData(dataObj, 0, 0)

        checkActions();
        drawMap();
        drawSprites();
        
        t[1] = (timestamp - t[0]) >> 4;
        t[3] = t[1] - t[2];
        t[2] = t[1];

        test.innerHTML = ((window.performance.now() - timestamp) | 0) + " milliseconds to draw frame "// + t[3];
        
      //}
      if (!PAUSED) window.requestAnimationFrame(loop);
    }

    buildPhysicalMap();
    setupSpriteMovement();
    loop();
    
    function empty(){
      //DO NOTHING
    }



    function drawMap(){
      //var start = Date.now();

      var layers_len = layers.length,
          map_size = DIMENSIONS,
          m_data = MAP_DATA;    
                

      for (var i=0; i<256; i++){
        var x_offset = (i & 15) << 4,
            y_offset = (i >> 4) << 4
        
        for (var j=0; j<256; j++){
          var x = (j & 15) + x_offset,
              y = (j >> 4) + y_offset;

          var pixel, index = (x * 4) + (y * 1024);
          
          for (var z=0; z<layers_len;z++){
            var layer = layers[z];

            var overflow_x = ((j & 15) + layer.x_offset + scrollPos.x_offset > 15) | 0,
                overflow_y = (j + ((layer.y_offset + scrollPos.y_offset) << 4) > 255) | 0,
                pixel_offset = (j + layer.x_offset + scrollPos.x_offset + ((layer.y_offset + scrollPos.y_offset) << 4)) - (overflow_x << 4) - (overflow_y << 8);


            var map_x = (x_offset >> 4) + layer.x + scrollPos.x + overflow_x,
                map_y = (y_offset >> 4) + layer.y + scrollPos.y + overflow_y;
  
            var map_index = (map_x & (map_size[layer.index].x - 1)) + ((map_y & (map_size[layer.index].y - 1)) * map_size[layer.index].x),
                tile_index = m_data[layer.index][map_index],
                tile_data = layer.data[tile_index];

            var animated_offset = pixel_offset + (256 * animated_frame);
            
            var color_index = tile_data[animated_offset] === void(0) ? tile_data[pixel_offset] : tile_data[animated_offset];

            pixel = PALETTE[color_index];
            if( pixel[3] === 255 ){ 
              pixelMap[x][y] = z
              break;
            }
          }
        
          drawPixel(data, pixel, index)
        }
      }
    }

    function drawSprites(){
      // TODO: This will need to be broken up into subroutines so that sprites can be drawn according to priority
      // to get the layering exact.
      var _sprites = SPRITES,
          _scrollPos = scrollPos,
          _spritePositions = SPRITE_POSITIONS;

      var mapBounds = {
        x1: (_scrollPos.x << 4) + _scrollPos.x_offset,
        x2: (_scrollPos.x << 4) + _scrollPos.x_offset + 256,
        y1: (_scrollPos.y << 4) + _scrollPos.y_offset,
        y2: (_scrollPos.y << 4) + _scrollPos.y_offset + 256,

      }

      for (var i=0; i<_sprites.length; i++){
        var sprite = _sprites[i],
          back_edge = (sprite.coords.x << 4) + sprite.coords.x_offset,
          top_edge = (sprite.coords.y << 4) + sprite.coords.y_offset,
          spritePos = _spritePositions[sprite.position];

        if (back_edge + 16 > mapBounds.x1 && back_edge < mapBounds.x2 && top_edge + 24 > mapBounds.y1 && top_edge < mapBounds.y2){
          for (var b=0; b<6; b++){
            var x_offset = (b & 1) << 3,
                y_offset = (b >> 1) << 3;

            for (var y=0; y<8; y++){
              for (var x=0; x<8; x++){
                var color = sprite.tiles[spritePos[b]][x + (y << 3)],
                    x_pixel = sprite.mirror === 0 ? x + x_offset : 15 - (x + x_offset),
                    data_x = (back_edge - mapBounds.x1) + x_pixel,
                    data_y = (y + (top_edge - mapBounds.y1)) + y_offset;

                if (data_x < 0 || data_x > 255 || data_y < 0 || data_y > 255 || color[3] === 0) continue

                var data_offset = ((data_x) + ((data_y) * 256)) * 4
                if (pixelMap[data_x][data_y] <= sprite.priority) drawPixel(data, color, data_offset)
              }
            }
          }
        }
      }

      drawCharacter(mapBounds, _spritePositions);
    }

    function drawCharacter(mapBounds, sprite_positions){
      var sprite = CHARACTER;
          
      var back_edge = (sprite.coords.x << 4) + sprite.coords.x_offset,
          top_edge =  ((sprite.coords.y - 1) << 4) + sprite.coords.y_offset,
          spritePos = sprite_positions[sprite.position];

      for (var b=0; b<6; b++){
        var x_offset = (b & 1) << 3,
            y_offset = (b >> 1) << 3,
            sprite_priority = y_offset === 16 ? sprite.priority + 1 : sprite.priority;

        for (var y=0; y<8; y++){
          for (var x=0; x<8; x++){
            var color = sprite.tiles[spritePos[b]][x + (y << 3)],
                x_pixel = sprite.mirror === 0 ? x + x_offset : 15 - (x + x_offset),
                data_x = (back_edge - mapBounds.x1) + x_pixel,
                data_y = (y + (top_edge - mapBounds.y1)) + y_offset;

            if (color[3] === 0) continue

            var data_offset = ((data_x) + ((data_y) * 256)) * 4;

            if (sprite_priority <= pixelMap[data_x][data_y]) drawPixel(data, color, data_offset)
            
          }
        }
      }
    }

    //TODO: be able to set width. Needed for mode7
    function drawPixel(data, pal, index){
      data[index] = pal[0]
      data[index + 1] = pal[1]
      data[index + 2] = pal[2]
      data[index + 3] = pal[3]

      // data[index + 4] = pal[0]
      // data[index + 5] = pal[1]
      // data[index + 6] = pal[2]
      // data[index + 7] = pal[3]

      // data[index + 2048] = pal[0]
      // data[index + 2049] = pal[1]
      // data[index + 2050] = pal[2]
      // data[index + 2051] = pal[3]

      // data[index + 2052] = pal[0]
      // data[index + 2053] = pal[1]
      // data[index + 2054] = pal[2]
      // data[index + 2055] = pal[3]
    }

    function buildPhysicalMap(){
      var props = TILE_PROPERTIES,
          tiles = MAP_DATA[0],
          map_size = DIMENSIONS[0],
          map = PHYSICAL_MAP;

      var props_tiles = document.getElementById("props");
      props_tiles.style.width = (32 * map_size.x) + "px";

      for (var i=0; i<tiles.length; i++){
        var p = document.createElement("div");

        p.className = "prop"
        p.innerHTML = "<span>" + ((props[tiles[i]][0] & 240) >> 4).toString(2) + "</span><span>" + (props[tiles[i]][0] & 15).toString(2) + "</span><span> " +  ((props[tiles[i]][1] & 240) >> 4).toString(2) + "</span><span>" + (props[tiles[i]][1] & 15).toString(2) + "</span>";
        props_tiles.appendChild(p);
        
        var x = i & (map_size.x - 1),
            y = ((i / map_size.x) | 0);

        var prop = props[tiles[i]];

        if (map[x] === void(0)) map[x] = {};

        map[x][y] = {
          stairs: (prop[0] & 192) >> 6 === 3 ? 2 : (prop[0] & 192) >> 6,
          east: true, //prop[0] !== 0xf8,
          west: true, //prop[0] !== 0xf8,
          north: true, //prop[0] !== 0xf8,
          south: true, //prop[0] !== 0xf8,
          tile_number: tiles[i]
        }

        // map[x][y] = {
        //   stairs: (prop[0] & 192) >> 6 === 3 ? 2 : (prop[0] & 192) >> 6,
        //   canMove: (prop[0] & 4) === 4,
        //   west: (prop[1] & 1) === 1,
        //   east: (prop[1] & 2) === 2,
        //   north: (prop[1] & 4) === 4,
        //   south: (prop[1] & 8) === 8,
        //   solid: (prop[0] & 8) !== 8,
        //   solidToLayer1: prop[0] & 1 + 1,
        //   solidToLayer2: prop[0] & 2 + 1,
        //   tile_number: tiles[i]
        // }
      }
    }

    window.addEventListener("keydown", function(e){
      if (e.keyCode === 37){
        moveLeft(); scrollL = true;
      } else if (e.keyCode === 38) {
        moveUp(); scrollU = true;
      } else if (e.keyCode === 39) {
        moveRight(); scrollR = true;
      } else if (e.keyCode === 40) {
        moveDown(); scrollD = true;
      }
    }, false)

    var toggle = true;  
    window.addEventListener("keyup", function(e){
      if (e.keyCode === 37){
        scrollL = false;
      } else if (e.keyCode === 38) {
        scrollU = false;
      } else if (e.keyCode === 39) {
        scrollR = false;
      } else if (e.keyCode === 40) {
        scrollD = false;
      } else if (e.keyCode === 49) {
        console.log(toggle);
        ctx.canvas.style.display = toggle ? 'none' : 'block';
        toggle = !toggle; 
      }
    }, false)
    // })
  
    document.getElementById('stop').addEventListener("click", function(){
      if (PAUSED === true){
        PAUSED = false;
        loop();
      } else {
        PAUSED = true;
      }
    }, false)

    function scrollLeft(speed){
      var s = scrollPos;
      
      s.x -= 1;
      s.x_offset = 15;
      tile_props.style.marginLeft = (s.x * -32) + "px";
      

      iterate(2, 14, function(){
        s.x_offset -= 1
      }, function(){ 
        s.x_offset = 0; 
      }, false)
    }

    function scrollRight(speed){
      iterate(2, 15, function(){
        scrollPos.x_offset += 1;
      }, function(){ 
        scrollPos.x_offset = 0;
        scrollPos.x += 1; 
        tile_props.style.marginLeft = (scrollPos.x * -32) + "px";
      }, true)
    }

    function scrollUp(){
      var s = scrollPos;
      
      s.y -= 1;
      s.y_offset = 15;
      tile_props.style.marginTop = (scrollPos.y * -32)  + "px";
      
      iterate(2, 14, function(){
        s.y_offset -= 1
      }, function(){ 
        s.y_offset = 0; 
      }, false)
    }

    function scrollDown(){
      iterate(2, 15, function(){
        scrollPos.y_offset += 1;
      }, function(){ 
        scrollPos.y_offset = 0;
        scrollPos.y += 1; 
        tile_props.style.marginTop = (scrollPos.y * -32) + "px";
      }, true)
    }
  </script>
</div>