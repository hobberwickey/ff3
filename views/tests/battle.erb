<div>
  <div id='drawTime'></div>
  <div><a id='next_bg' href='javascript:void(0)'>Next BG</a></div>
  <div><a id='previous_palette' href='javascript:void(0)'>Previous Palette</a></div>
  <div><a id='next_palette' href='javascript:void(0)'>Next Palette</a><div>
  
  <div id='screen_wrapper' style='position: relative; width: 512px; height: 512px; margin: -50px auto 0 auto; overflow: hidden;'>
    <canvas id='screen' width='256' height='256' style='background-color: #00f; transform: scale(2); transform-origin: 0 0;'></canvas>
  </div>
  

  <script>
  var BG = JSON.parse('<%= @battle.background.to_json %>'),
      BG_DATA = BG.data,
      BG_DATA_INDEX = 0,
      PALETTES = BG.palettes,
      PALETTE_INDEX = 0,
      ASSEMBLY_DATA = BG.assembly,
      INFO = BG.info,
      INFO_INDEX = 0;

    // document.addEventListener("polymer-ready", function(){
    var ctx = document.querySelector("#screen").getContext("2d"),
        dataObj = ctx.getImageData(0,0,256,256),
        data = dataObj.data;

    document.querySelector("#next_palette").addEventListener('click', function(){
      PALETTE_INDEX += 1;
      if (PALETTES[PALETTE_INDEX] === void(0)) PALETTE_INDEX = 0;

      drawBG();
    }, false);

    document.querySelector("#previous_palette").addEventListener('click', function(){
      PALETTE_INDEX -= 1;
      if (PALETTES[PALETTE_INDEX] === void(0)) PALETTE_INDEX = PALETTES.length - 1;

      drawBG();
    }, false);

    document.querySelector("#next_bg").addEventListener('click', function(){
      INFO_INDEX += 1;
      if (INFO[INFO_INDEX] === void(0)) INFO_INDEX = 0;

      drawBG();
    }, false);

    var test = document.querySelector("#drawTime");
  
    //var start = Date.now();
    // var timing = [ 
    //   window.performance.now(), // start time
    //   0, // frames
    //   0, // last draw
    //   0  // advanced
    // ]

    // function loop(timestamp) {
    //   //if (Date.now() - start > fps){ //24 FPS
    //     var t = timing;

    //     ctx.putImageData(dataObj, 0, 0)

    //     checkActions();
    //     drawMap();
    //     drawSprites();
        
    //     t[1] = (timestamp - t[0]) >> 4;
    //     t[3] = t[1] - t[2];
    //     t[2] = t[1];

    //     // test.innerHTML = ((window.performance.now() - timestamp) | 0) + " milliseconds to draw frame "// + t[3];
        
    //   //}
    //   if (!PAUSED) window.requestAnimationFrame(loop);
    // }

    // buildPhysicalMap();
    // setupSpriteMovement();
    // loop();
    
    // function empty(){
    //   //DO NOTHING
    // }


    function drawBG(){
      //TODO: Remove, this is just for clearing the canvas
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
      dataObj = ctx.getImageData(0,0,256,256),
      data = dataObj.data;

      var tiles = [[],[],[]],
          lens = [];

      var info = INFO[INFO_INDEX]

      var tilesets = [info[0] & 127, info[1] & 127, info[2] & 127];
      for (var i=0; i<3; i++){
        var tileset = BG_DATA[tilesets[i]];
        if (!tileset){
          lens.push(0);
        } else {
          lens.push(tileset.length);
          for (var j=0; j<tileset.length; j++){
            tiles[i].push(tileset[j]);
          }
        }
      }

      var bg_data = BG_DATA,
          bg_data_index = BG_DATA_INDEX,
          palettes = PALETTES,
          palette_index = PALETTE_INDEX;

      var assembly1 = ASSEMBLY_DATA[info[3]],
          assembly2 = ASSEMBLY_DATA[info[4]];
          
      for (var i=0; i<608; i++){
        var assembly = 1 > 288 ? assembly2 : assembly1
        var part1 = assembly[i * 2],
            part2 = assembly[(i * 2) + 1],
            tileset = (((part2 & 1) ) + ((part1 & 128) >> 7))
            tile_number = part1 & 127;
        
        var hFlip = (part2 & 64) === 64,
            vFlip = (part2 & 128) === 128;

        var tile = tiles[tileset][tile_number],
            palette = palettes[palette_index],
            x_offset = (i % 32),
            y_offset = ((i / 32) | 0);
        
        if (!tile){
          continue
        }

        for (var y=0; y<8; y++){
          var y_pos = vFlip ? 7 - y : y;

          for (var x = 0; x < 8; x++){
            var x_pos = hFlip ? 7 - x : x;

            var index = (x_pos * 4) + (y_pos * 1024) + (x_offset * 32) + (y_offset * 8192),
                color = palette[tile[x + (y * 8)]];

            drawPixel(data, color, index);
          }
        }
      }

      test.innerHTML = "PALLETE INDEX: " + palette_index + " TILESET: " + bg_data_index;
      ctx.putImageData(dataObj, 0, 0)
    }

    drawBG();
    // function drawMap(){
    //   //var start = Date.now();

    //   var layers_len = layers.length,
    //       map_size = DIMENSIONS,
    //       m_data = MAP_DATA;    
                

    //   for (var i=0; i<256; i++){
    //     var x_offset = (i & 15) << 4,
    //         y_offset = (i >> 4) << 4
        
    //     for (var j=0; j<256; j++){
    //       var x = (j & 15) + x_offset,
    //           y = (j >> 4) + y_offset;

    //       var pixel, index = (x * 4) + (y * 1024);
          
    //       for (var z=0; z<layers_len;z++){
    //         var layer = layers[z];

    //         var overflow_x = ((j & 15) + layer.x_offset + scrollPos.x_offset > 15) | 0,
    //             overflow_y = (j + ((layer.y_offset + scrollPos.y_offset) << 4) > 255) | 0,
    //             pixel_offset = (j + layer.x_offset + scrollPos.x_offset + ((layer.y_offset + scrollPos.y_offset) << 4)) - (overflow_x << 4) - (overflow_y << 8);


    //         var map_x = (x_offset >> 4) + layer.x + scrollPos.x + overflow_x,
    //             map_y = (y_offset >> 4) + layer.y + scrollPos.y + overflow_y;
  
    //         var map_index = (map_x & (map_size[layer.index].x - 1)) + ((map_y & (map_size[layer.index].y - 1)) * map_size[layer.index].x),
    //             tile_index = m_data[layer.index][map_index],
    //             tile_data = layer.data[tile_index];

    //         var animated_offset = pixel_offset + (256 * animated_frame);
    //         try{
    //         var color_index = tile_data[animated_offset] === void(0) ? tile_data[pixel_offset] : tile_data[animated_offset];
    //       } catch(e){
    //         console.log(animated_offset, pixel_offset)
    //         throw "Error"
    //       }
    //         pixel = PALETTE[color_index];
    //         if( pixel[3] === 255 ){ 
    //           pixelMap[x][y] = z
    //           break;
    //         }
    //       }
        
    //       drawPixel(data, pixel, index)
    //     }
    //   }
    // }

    // function drawCharacter(mapBounds, sprite_positions){
    //   var sprite = CHARACTER;
          
    //   var back_edge = (sprite.coords.x << 4) + sprite.coords.x_offset,
    //       top_edge =  ((sprite.coords.y - 1) << 4) + sprite.coords.y_offset,
    //       spritePos = sprite_positions[sprite.position],
    //       physical_tile = PHYSICAL_MAP[sprite.coords.x][sprite.coords.y],
    //       upperMask = sprite.priority === 0 && PHYSICAL_MAP[sprite.coords.x][sprite.coords.y - 1].mask === 1,
    //       lowerMask = sprite.priority === 0 && PHYSICAL_MAP[sprite.coords.x][sprite.coords.y].mask === 1,
    //       upperPriority = sprite.priority === 0 ? (physical_tile.drawPriority > 1) | 0 : (physical_tile.drawPriority > 0) | 0,
    //       lowerPriority = 0;


    //   for (var b=0; b<6; b++){
    //     var x_offset = (b & 1) << 3,
    //         y_offset = (b >> 1) << 3; 

    //     var layer = b < 4 ? upperPriority : lowerPriority;
    //         mask = b < 4 ?  upperMask : lowerMask;

    //     test.innerHTML = "Draw Priority is: " + upperPriority + " Sprite Priority is: " + sprite.priority + " Upper mask: " + upperMask + " Lower mask: " + lowerMask;
        

    //     for (var y=0; y<8; y++){
    //       for (var x=0; x<8; x++){
    //         var color = sprite.tiles[spritePos[b]][x + (y << 3)],
    //             x_pixel = sprite.mirror === 0 ? x + x_offset : 15 - (x + x_offset),
    //             data_x = (back_edge - mapBounds.x1) + x_pixel,
    //             data_y = (y + (top_edge - mapBounds.y1)) + y_offset;

    //         if (color[3] === 0) continue

    //         var data_offset = ((data_x) + ((data_y) * 256)) * 4;


    //         if (layer === 0 || mask){ 
    //           if (mask){
    //             //if (pixelMap[data_x][data_y] === 2) drawPixel(data, color, data_offset)
    //           } else {
    //             if (pixelMap[data_x][data_y] !== 1 && pixelMap[data_x][data_y] !== 0) drawPixel(data, color, data_offset)
    //           }
    //         } else {
    //           drawPixel(data, color, data_offset)
    //         } 
    //       }
    //     }
    //   }
    // }

    //TODO: be able to set width. Needed for mode7
    function drawPixel(data, pal, index){
      data[index] = pal[0]
      data[index + 1] = pal[1]
      data[index + 2] = pal[2]
      data[index + 3] = pal[3]

      // data[index + 4] = pal[0]
      // data[index + 5] = pal[1]
      // data[index + 6] = pal[2]
      // data[index + 7] = pal[3]

      // data[index + 2048] = pal[0]
      // data[index + 2049] = pal[1]
      // data[index + 2050] = pal[2]
      // data[index + 2051] = pal[3]

      // data[index + 2052] = pal[0]
      // data[index + 2053] = pal[1]
      // data[index + 2054] = pal[2]
      // data[index + 2055] = pal[3]
    }
  </script>
</div>